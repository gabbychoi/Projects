# 쿼리 교정 가이드

현재 자주 관찰되는 부적절한 쿼리에 대한 교정 가이드입니다.

### 1. 정수형 날짜 데이터 처리

```sql

/* 정수 형태의 날짜 포맷을 이렇게 처리하는 경우가 많습니다 */

SELECT LEFT(DATEKEY,4) AS YEAR,
			 SUBSTRING(DATEKEY,5,2) AS MONTH,
			 RIGHT(DATEKEY,2) AS DAY

/* 해당 쿼리는 문자열 참조를 위해 정수형 날짜를 강제로 형변환하며 복잡도가 증가합니다.
또한 문자형 결과 집합을 내놓기에 정렬작업시 사전 정렬을 수행하기에 숫자형 형변환을 또 해야하죠.
따라서 아래처럼 쿼리 패턴을 바꿔줍시다. */

SELECT DATEKEY/10000 AS YEAR,
			 (DATEKEY%10000)/100 AS MONTH,
			 DATEKEY%100 AS DAY
			 
/* 정수형 데이터 처리에 추가적인 형변환 없이 연도, 월, 일 형태의 데이터를 추출할 수 있습니다.
단 실수형태인 경우 나눗셈을 소숫점계산을 진행하기에 이런 패턴이 불가능합니다.*/

/* 특별히 문자열 형태를 유지해야 한다면 다음처럼 접근합니다. 
이 패턴은 정수형날짜의 일부를 꺼내 다른 문자열과 조합해야 할때 유용합니다. */

SELECT 
		LEFT(NEW_DATEKEY,4) AS YEAR,
		SUBSTRING(DATEKEY,5,2) AS MONTH,
		RIGHT(DATEKEY,2) AS DAY

FROM(
		SELECT CONVERT(VARCHAR,DATEKEY) AS NEW_DATEKEY
) A

/* 첫번째 쿼리와 비교해보면 이 쿼리는 형변환 작업을 3회 하던 것에서 1회만 수행합니다. 
 이런 방식이 대량 데이터에서는 큰 성능 향상이 될 수 있습니다. 
 이런 형태는 소량일때는 크게 느끼지 못하지만 데이터가 억단위로 늘어나는 경우 성능에 유의미한 영향을 끼치게 됩니다.
 특히 형변환은 메모리를 소모하기때문에 대량데이터 처리시 메모리 자원이 부족하면 디스크를 할당해서 처리하는만큼 속도가 더 느려질 여지가 있죠.
 당장은 느끼지 못하는 속도 차이여도 위와같은 쿼리 습관이 있다면 교정하는 노력이 필요할 것입니다.
 */
```

### 2. 필요한 컬럼만 사용하기

```sql

SELECT *  -- 불필요한 컬럼 식별 필요
FROM TABLE

/* 불필요한 컬럼은 모델 크기를 증가시키고 쿼리 수행 속도가 늦어지게 하는 원인입니다. 
특히 NVARCHAR(MAX) 같은 레퍼런스형 데이터타입을 추가한 경우 I/O가 상당히 늘어나게 됩니다.
따라서 이런 데이터가 필요하지 않다면 쿼리에 입력하지 않는것이 좋습니다.
사실 이는 쿼리 작성 습관중 가장 중요한 내용인데, 쿼리를 작성해보면 CPU가 작업을 하는 시간보다
작업이 끝난 결과를 I/O 하는데에 시간을 매우 많이 잡아먹게 됩니다.
그만큼 데이터 성능에 매우 중대한 영향을 끼치는 쿼리 습관이 될 수 있음에 유의하길 바랍니다.
*/

SELECT 
		COL1,
		COL2,
		COL3
FROM TABLE

```

### 3. union all 과 union 처리

```sql
/* Union 과 Union All 의 차이는 중복 제거 여부에 있습니다. 
UNION 이 중복을 제거하기에 결과 집합의 무결성을 보장하기는 합니다.
하지만 정렬을 수행하기에 다음같은 패턴의 쿼리에서는 자제해야합니다.

SELECT *

FROM TABLES
WHERE COLUMN1='A'

UNION

SELECT *
FROM TABLES
WHERE COLUMN1='B'

/* COLUMN1 이 A 이면서 동시에 B 가 되는 경우는 있을수 없습니다. 두 결과는 완전히 분리되죠.
이 경우 정렬이 필요하지 않은 상황이면 다음과 같이 쿼리를 변경해줍니다.
SELECT *

FROM TABLES
WHERE COLUMN1='A'

UNION ALL  -- UNION ALL 로 변경

SELECT *
FROM TABLES
WHERE COLUMN1='B'
```

### 4. 인덱스 비활성화

```sql

/* 
인덱스가 걸린 테이블에 INSERT INTO SELECT 를 진행하는 과정입니다.
이는 인덱스 오버헤드를 고려하지 않아 오버헤드가 그냥 유지되는 경우가 많습니다.
이에 대한 추가적인 고려가 들어가야 합니다.
인덱스는 소수데이터 SELECT 의 편의성을 위해 나머지 DML의 부하를 감내하고 작성하는 구조입니다.
그저 데이터베이스 조회를 빠르게 해주는 개념으로 접근해서는 안됩니다.
이토록 인덱스는 DML에 엄청난 부하를 주기에 일시적으로 사용을 중단시키는 기능이 제공됩니다.
일반적인 OLTP 환경에서는 잘 사용하지 않지만 대량 데이터를 한번에 처리해야하는 DW 환경에서는 매우 유용한 접근 방식입니다.
*/

-- 기존 데이터 삭제
DELETE FROM TARGET_TABLE
		WHERE FLAG_DATE>=@FLAG_DATE
		
-- BULK INSERT 실행
INSERT INTO TARGET_TABLE
SELECT *
FROM SOURCE_TABLE
WHERE CREATE_DATE>=@FLAG_DATE

/* 이럴 경우 다음과 같이 쿼리 패턴을 수정해줍시다.*/

-- 인덱스 비활성화
ALTER INDEX [IndexName] ON [dbo].[TARGET_TABLE] DISABLE;

-- 기존 데이터 삭제
DELETE FROM TARGET_TABLE
WHERE FLAG_DATE >= @FLAG_DATE;

-- BULK INSERT 실행
INSERT INTO TARGET_TABLE
SELECT *
FROM SOURCE_TABLE
WHERE CREATE_DATE>=@FLAG_DATE
-- 인덱스 재구성
ALTER INDEX IndexName ON TARGET_TABLE REBUILD;

/* 또한 대량의 데이터 (1억건 이상) 의 경우 다음과 같은 패턴을 이용할 수 있습니다.*/

-- 1. 인덱스 비활성화
ALTER INDEX IndexName ON TARGET_TABLE DISABLE;

-- 2. 기존 데이터 파티션 삭제 (TRUNCATE)
-- Assuming the table is partitioned by FLAG_DATE and using a specific partition function
BEGIN TRY
    -- Start Transaction
    BEGIN TRANSACTION;

    -- Truncate specific partition based on FLAG_DATE
    DECLARE @PartitionNumber INT;

    -- Get the partition number for the given FLAG_DATE
    SELECT @PartitionNumber = $PARTITION.partition_function_name(FLAG_DATE)
    FROM dbo.TARGET_TABLE
    WHERE FLAG_DATE = @FLAG_DATE;

    -- Build dynamic SQL for truncating the specific partition
    DECLARE @SQL NVARCHAR(MAX);
    SET @SQL = N'TRUNCATE TABLE dbo.TARGET_TABLE WITH (PARTITIONS(' + CAST(@PartitionNumber AS NVARCHAR) + '));';

    -- Execute dynamic SQL
    EXEC sp_executesql @SQL;

    -- Commit Transaction
    COMMIT TRANSACTION;
END TRY
BEGIN CATCH
    -- Rollback Transaction on Error
    ROLLBACK TRANSACTION;
    -- Handle error
    THROW;
END CATCH;

-- 3. INSERT 실행
INSERT INTO TARGET_TABLE WITH(TABLELOCK) -- 다른 요청이 상호작용할 필요 없는 작업이리면 TABLELOCK 으로 성능 극대화. 
SELECT 
FROM SOURCE_TABLE
WHERE FLAG_DATE = @FLAG_DATE;

-- 4. 인덱스 재구성
ALTER INDEX IndexName ON TARGET_TABLE REBUILD;

```

### 5. 스칼라 서브쿼리

```sql

/* 종종 스칼라 서브쿼리를 이용하는 경우가 있습니다. */
SELECT 
		(SELECT COLUMN_1 FROM TABLE_B WHERE COLUMN_0=A.COLUMN_2)

FROM TABLE_A A

/*TABLE_B 와 TABLE_A 가 일대다 형태라면 우선 조인으로 바꾸는걸 고려해보세요.
조회 행수만큼 쿼리가 수행될것을 한번의 호출로 줄일 수 있습니다.
*/ 

SELECT 
		B.COLUMN_1
		
FROM TABLE_A A
JOIN TABLE_B B
ON B.COLUMN_0=A.COLUMN_2

/* 부득이하게 스칼라 서브쿼리를 이용해서 접근한다면 한다면 다음을 고려합시다.
   TABLE_B 가 크기가 매우 작으면 그대로 유지해도 괜찮습니다. 
   유지하면서 성능을 모니터링 해주세요 */

SELECT 
		(SELECT COLUMN_1 FROM TABLE_B WHERE COLUMN_0=A.COLUMN_2)
FROM TABLE_A A

/* 
TABLE_B 가 매우 크면 부하가 발생합니다. 이경우엔 조인조건에 인덱스를 활용할 수 있도록 유도해줍시다. 
기존 인덱스가 존재한다면 그쪽으로 유도하고 시스템 부하를 고려해 인덱스 추가여부를 결정 합시다.
*/

SELECT 
			(SELECT COLUMN_1 
			 FROM TABLE_B WITH(IX_1)
			 WHERE 1=1 
				  AND INDEX_COLUMN_B=COLUMN_A
				  AND COLUMN_0=A.COLUMN_2)
FROM TABLE_A A

/* 여기 단계까지 와서도 어렵다면 쿼리를 재설계를 고려해봅시다. */

/* 일반적으로 서브쿼리는 시스템에 큰 부하를 준다고 여겨져 적절하지 않다곤 하지만 사실 그렇지 않습니다. 
불필요한 연산을 최적화할 수 있는 능력이 있다면 원하는 값을 빠르게 찾아 생산성을 높일 수 있는 방식이 됩니다.
물론 스칼라 서브쿼리의 경우 상당한 부하를 줄 수 있는 위험성을 내재하고 있어 가급적 사용을 자제하라는 말이 이해가 되지 않는것은 아닙니다만.
그러니 더더욱 쿼리의 수행 계획을 이해하고 연산 횟수를 줄이려는 노력을 해야 합니다. 
*/

```

### 6. Aggregations 최적화

```sql
/* 서브쿼리로 인한 부하를 피하기 위한다는 이유로 이런 쿼리가 작성되는 경우가 종종 있습니다. */

SELECT A.COLUMN1,
       A.COLUMN2,
       SUM(A.COLUMN3) AS COL3SUM,
       B.COL4,
       B.COL5
FROM A
JOIN B ON A.ID = B.A_ID
GROUP BY A.COLUMN1, A.COLUMN2, B.COL4, B.COL5;

/* 하지만 B 와 A 가 일대다 관계라면 각 결과에 B를 조인하는 연산이 늘어나는 문제가 생깁니다.
이런 경우 쿼리를 이렇게 변형하면 최적화된 결과를 얻을 수 있습니다.
*/

SELECT A.COLUMN1,
       A.COLUMN2,
       A.COL3SUM,
       B.COL4,
       B.COL5
FROM (
    SELECT ID, COLUMN1, COLUMN2, SUM(COLUMN3) AS COL3SUM
    FROM A
    GROUP BY ID, COLUMN1, COLUMN2
) A
JOIN B ON A.ID = B.A_ID;

/* 각 그룹핑 결과를 조인하는 형태로 서브쿼리를 활용한 예시입니다. 
이는 A 가 집계 컬럼 NDV 대비 테이블 데이터 수가 매우 큰 경우에는 극적인 효과를 볼 수 있습니다.
*/
```

### 7. 조인 순서 최적화.

```sql
/* 대량 데이터 조인 수행 시에는 작은 테이블을 Driving 테이블(선행 테이블)로 두는것이 적절합니다.
조건별 범위 처리시 작은 쪽을 우선 필터처리하는것이 적절하기 때문입니다. */

SELECT

FROM SMALL_TABLE A WITH(INDEX(0)) -- 작은 데이터에대한 풀 스캔 요청
JOIN LARGE_TABLE B
ON A.KEY=B.KEY
WHERE A.COLUMN_1 =:INPUT -- 작은 테이블에 대한 필터 조건 기입

/* 하지만 큰 테이블에서 인덱스를 이용하여 효율적으로 필터링을 진행할 수 있고, 
   B 테이블 접근에 대한 방식. 최적화가 어렵다면 큰 테이블을 Driving 하는것을 고려해봅시다.*/

SELECT 

FROM LARGE_TABLE A WITH(INDEX(IX))
JOIN SMALL_TABLE B
ON A.KEY=B.KEY
WHERE 1=1
AND A.INDEX_COLUMN_1=:INPUT_1 -- 큰 테이블에 대한 인덱스 조건 기입
AND A.INDEX_COLUMN_2=:INPUT_2 -- 
...

```